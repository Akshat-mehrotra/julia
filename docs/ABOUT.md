The creators of Julia want to eat their cake and have it too. As they describe in their blog post ["Why We Created Julia"](http://julialang.org/blog/2012/02/why-we-created-julia) they want the speed of C, the dynamism of Ruby, the familiar mathematical notation of Matlab. They want it to be their favourite things from their favourite languages. String processing like Perl. Glue like the shell. Powerful but not impenetrably complex.

Julia has a dynamic, nominative and parametric [type system](http://docs.julialang.org/en/stable/manual/types/). This allows writing dynamic code and specifying types if additional expressiveness is needed for simplification or performance increases. The language features multiple dispatch, meaning it chooses which method is called based on the types of each argument. This lets you write specific methods for certain types while providing generic fallbacks and is particularly useful for mathematical code, where it is not clear why an operation should belong to a specific argument.

[Metaprogramming](http://docs.julialang.org/en/stable/manual/metaprogramming/) is easy in Julia due to its homoiconicity, i.e. Julia code can be represented in Julia itself. Large parts of [Julia's base library](https://github.com/julialang/julia) are also written in Julia. Understanding and changing it does not require knowledge of another language. If a library you need to use is written in another language, such as [C, Fortran](http://docs.julialang.org/en/stable/manual/calling-c-and-fortran-code/) or [Python](https://github.com/JuliaPy/PyCall.jl), you can use simple interfaces to call them directly from your code.

Despite its young age, Julia is already being used in the real world in a variety of fields, such as but not limited to Finance, Data Science and Scientific Computing. You can find many showcase applications on [juliabloggers.com](http://www.juliabloggers.com/) and a list of publications about the language and its technical computing applications [here](http://julialang.org/publications/).
